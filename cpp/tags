!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AVLTree	avl_tree.h	/^class AVLTree$/;"	c
AVLTree	avl_tree.h	/^template<typename Type> AVLTree<Type>::AVLTree():mRoot(NULL),mLength(0)$/;"	f	class:AVLTree
AVLTree	avl_tree.h	/^template<typename Type> AVLTree<Type>::AVLTree(Type arr[],int nLength):mRoot(NULL),mLength(0)$/;"	f	class:AVLTree
Abstraction	design_pattern/bridge/Bridge.cpp	/^Abstraction::Abstraction(Implementor* pImplementor) : m_pImplementor(pImplementor)$/;"	f	class:Abstraction
Abstraction	design_pattern/bridge/Bridge.h	/^class Abstraction$/;"	c
Add	design_pattern/composite/Composite.cpp	/^void Composite::Add(Component* pChild)$/;"	f	class:Composite
Add	design_pattern/composite/Composite.h	/^    virtual void Add(Component* pChild){}\/\/添加一个子部件$/;"	f	class:Component
AddedBehavior	design_pattern/decorator/Decorator.cpp	/^void ConcreateDecorator::AddedBehavior()$/;"	f	class:ConcreateDecorator
Aggregate	design_pattern/iterator/Iterator.h	/^class Aggregate$/;"	c
Attach	design_pattern/observer/Observer.cpp	/^void Subject::Attach(Observer *pObserver)$/;"	f	class:Subject
B	static_cast.cpp	/^struct B {};$/;"	s	file:
BRIDEG_H	design_pattern/bridge/Bridge.h	2;"	d
BUFFER	net/recv.c	11;"	d	file:
BUFFER_LENGTH	producer_consumer.cpp	/^const int BUFFER_LENGTH = 100;$/;"	v
BUFFER_LENGTH	test/producer_consumer.c	/^const int BUFFER_LENGTH = 100;$/;"	v
BUFFER_SIZE	net/send.c	10;"	d	file:
BUF_SIZE	test/pipe/socket_pair.cpp	8;"	d	file:
BUILDER_H	design_pattern/build/Builder.h	2;"	d
Base	11/share_ptr.cpp	/^    Base() { std::cout << "  Base::Base()\\n"; }$/;"	f	struct:Base
Base	11/share_ptr.cpp	/^struct Base$/;"	s	file:
Builder	design_pattern/build/Builder.h	/^    Builder(){};$/;"	f	class:Builder
Builder	design_pattern/build/Builder.h	/^class Builder$/;"	c
BuilderPartA	design_pattern/build/Builder.cpp	/^void ConcreateBuilder1::BuilderPartA()$/;"	f	class:ConcreateBuilder1
BuilderPartA	design_pattern/build/Builder.cpp	/^void ConcreateBuilder2::BuilderPartA()$/;"	f	class:ConcreateBuilder2
BuilderPartB	design_pattern/build/Builder.cpp	/^void ConcreateBuilder1::BuilderPartB()$/;"	f	class:ConcreateBuilder1
BuilderPartB	design_pattern/build/Builder.cpp	/^void ConcreateBuilder2::BuilderPartB()$/;"	f	class:ConcreateBuilder2
COMPOSITE_H	design_pattern/composite/Composite.h	2;"	d
CONSUMER_NUM	test/queue.c	7;"	d	file:
CONSUM_SPEED	producer_consumer2.cpp	10;"	d	file:
Channel	net/reactor.cpp	/^Channel::Channel(EventLoop* loop,int fdArg):loop_(loop),fd_(fdArg),events_(0),revents_(0),index_(-1){}$/;"	f	class:Channel
Channel	net/reactor.cpp	/^class Channel:noncopyable{$/;"	c	file:
ChannelList	net/reactor.cpp	/^    typedef vector<Channel*> ChannelList;\/\/Channel容器(Channel包含了文件描述符fd和fd注册的事件及事件回调函数)，Channel包含文件描述符及其注册事件及其事件回调函数，这里主要用于返回就绪事件集合$/;"	t	class:Poller	file:
ChannelList	net/reactor.cpp	/^    typedef vector<Channel*> ChannelList;\/\/事件分发器Channel容器，一个Channel只负责一个文件描述符fd的事件分发$/;"	t	class:EventLoop	file:
ChannelMap	net/reactor.cpp	/^    typedef map<int,Channel*> ChannelMap;\/\/文件描述符fd到IO分发器Channel的映射，通过fd可以快速找到Channel$/;"	t	class:Poller	file:
ClassFoo	test/deque.cpp	/^namespace ClassFoo{$/;"	n	file:
Colleague	design_pattern/mediator/Mediator.h	/^    Colleague(Mediator* temp)$/;"	f	class:Colleague
Colleague	design_pattern/mediator/Mediator.h	/^class Colleague$/;"	c
ColleagueA	design_pattern/mediator/Mediator.h	/^    ColleagueA(Mediator* temp) : Colleague(temp){}$/;"	f	class:ColleagueA
ColleagueA	design_pattern/mediator/Mediator.h	/^class ColleagueA : public Colleague$/;"	c
ColleagueB	design_pattern/mediator/Mediator.h	/^    ColleagueB(Mediator* temp) : Colleague(temp){}$/;"	f	class:ColleagueB
ColleagueB	design_pattern/mediator/Mediator.h	/^class ColleagueB : public Colleague$/;"	c
Component	design_pattern/composite/Composite.h	/^    Component(string paramName){m_strName=paramName;}$/;"	f	class:Component
Component	design_pattern/composite/Composite.h	/^class Component$/;"	c
Component	design_pattern/decorator/Decorator.h	/^    Component(){}$/;"	f	class:Component
Component	design_pattern/decorator/Decorator.h	/^class Component$/;"	c
Composite	design_pattern/composite/Composite.h	/^    Composite(string strParam):Component(strParam){}$/;"	f	class:Composite
Composite	design_pattern/composite/Composite.h	/^class Composite : public Component$/;"	c
ConcreateAggregate	design_pattern/iterator/Iterator.cpp	/^ConcreateAggregate::ConcreateAggregate(int nSize) : m_nSize(nSize), m_pData(NULL)$/;"	f	class:ConcreateAggregate
ConcreateAggregate	design_pattern/iterator/Iterator.h	/^class ConcreateAggregate    : public Aggregate$/;"	c
ConcreateBuilder1	design_pattern/build/Builder.h	/^    ConcreateBuilder1(){}$/;"	f	class:ConcreateBuilder1
ConcreateBuilder1	design_pattern/build/Builder.h	/^class ConcreateBuilder1 : public Builder$/;"	c
ConcreateBuilder2	design_pattern/build/Builder.h	/^    ConcreateBuilder2(){}$/;"	f	class:ConcreateBuilder2
ConcreateBuilder2	design_pattern/build/Builder.h	/^class ConcreateBuilder2 : public Builder$/;"	c
ConcreateComponent	design_pattern/decorator/Decorator.h	/^    ConcreateComponent(){}$/;"	f	class:ConcreateComponent
ConcreateComponent	design_pattern/decorator/Decorator.h	/^class ConcreateComponent : public Component$/;"	c
ConcreateDecorator	design_pattern/decorator/Decorator.h	/^    ConcreateDecorator(Component* pComponent) : Decorator(pComponent){}$/;"	f	class:ConcreateDecorator
ConcreateDecorator	design_pattern/decorator/Decorator.h	/^class ConcreateDecorator    : public Decorator$/;"	c
ConcreateImplementorA	design_pattern/bridge/Bridge.h	/^    ConcreateImplementorA(){}$/;"	f	class:ConcreateImplementorA
ConcreateImplementorA	design_pattern/bridge/Bridge.h	/^class ConcreateImplementorA : public Implementor$/;"	c
ConcreateImplementorB	design_pattern/bridge/Bridge.h	/^    ConcreateImplementorB(){}$/;"	f	class:ConcreateImplementorB
ConcreateImplementorB	design_pattern/bridge/Bridge.h	/^class ConcreateImplementorB : public Implementor$/;"	c
ConcreateIterater	design_pattern/iterator/Iterator.h	/^class ConcreateIterater : public Iterater$/;"	c
ConcreateObserver	design_pattern/observer/Observer.cpp	/^ConcreateObserver::ConcreateObserver(Subject* sub) : Observer()$/;"	f	class:ConcreateObserver
ConcreateObserver	design_pattern/observer/Observer.h	/^    ConcreateObserver():Observer(){}$/;"	f	class:ConcreateObserver
ConcreateObserver	design_pattern/observer/Observer.h	/^class ConcreateObserver : public Observer $/;"	c
ConcreateSubject	design_pattern/observer/Observer.h	/^    ConcreateSubject() : Subject(){}$/;"	f	class:ConcreateSubject
ConcreateSubject	design_pattern/observer/Observer.h	/^class ConcreateSubject  : public Subject$/;"	c
ConcreteMediator	design_pattern/mediator/Mediator.h	/^class ConcreteMediator : public Mediator$/;"	c
Construct	design_pattern/build/Builder.cpp	/^void Director::Construct()$/;"	f	class:Director
ConsumerThread	test/queue.c	/^void *ConsumerThread(void *pvArg)$/;"	f
CreateIterater	design_pattern/iterator/Iterator.cpp	/^Iterater* ConcreateAggregate::CreateIterater(Aggregate *pAggregate)$/;"	f	class:ConcreateAggregate
CthreadPoolManage	test/cthreadpoolmanage.cpp	/^CthreadPoolManage::CthreadPoolManage()$/;"	f	class:CthreadPoolManage
CthreadPoolManage	test/cthreadpoolmanage.cpp	/^CthreadPoolManage::CthreadPoolManage(int min, int max, int waitSec)$/;"	f	class:CthreadPoolManage
D	11/unique_ptr.cpp	/^struct D {$/;"	s	file:
D	static_cast.cpp	/^struct D : B {};$/;"	s	file:
DATA	design_pattern/iterator/Iterator.h	/^typedef int DATA;$/;"	t
DDXX_AVLTREE_H	avl_tree.h	2;"	d
DECORATOR_H	design_pattern/decorator/Decorator.h	2;"	d
DELAY_TIME	test/queue.c	9;"	d	file:
Decorator	design_pattern/decorator/Decorator.h	/^    Decorator(Component* pComponent) : m_pComponent(pComponent){}$/;"	f	class:Decorator
Decorator	design_pattern/decorator/Decorator.h	/^class Decorator : public Component$/;"	c
DequeExample1	test/deque.cpp	/^    void DequeExample1() {$/;"	f	namespace:ClassFoo
Derived	11/share_ptr.cpp	/^    Derived() { std::cout << "  Derived::Derived()\\n"; }$/;"	f	struct:Derived
Derived	11/share_ptr.cpp	/^struct Derived: public Base$/;"	s	file:
Detach	design_pattern/observer/Observer.cpp	/^void Subject::Detach(Observer *pObserver)$/;"	f	class:Subject
Director	design_pattern/build/Builder.cpp	/^Director::Director(Builder* pBuilder) : m_pBuilder(pBuilder)$/;"	f	class:Director
Director	design_pattern/build/Builder.h	/^class Director$/;"	c
DisplayQue	test/queue.c	/^void DisplayQue(PT_QUEUE ptQue)$/;"	f
E	static_cast.cpp	/^enum class E { ONE, TWO, THREE };$/;"	c	file:
EU	static_cast.cpp	/^enum EU { ONE, TWO, THREE };$/;"	g	file:
EnterQue	test/queue.c	/^void EnterQue(PT_QUEUE ptQue, int dwElem)$/;"	f
EnumTableItem	lua/lua_test.c	/^static void EnumTableItem(lua_State *L, const char* lpszTableName)  $/;"	f	file:
EventCallback	net/reactor.cpp	/^    typedef function<void()> EventCallback;\/\/事件回调函数类型,回调函数的参数为空，这里将参数类型已经写死了$/;"	t	class:Channel	file:
EventLoop	net/reactor.cpp	/^EventLoop::EventLoop():looping_(false),quit_(false),threadID_(syscall(SYS_gettid)),poller_(new Poller(this)){$/;"	f	class:EventLoop
EventLoop	net/reactor.cpp	/^class EventLoop:noncopyable {$/;"	c	file:
FD_LIMIT	test/tick.c	17;"	d	file:
FP_CALC	typedef.c	/^typedef int (*FP_CALC)(int, int);$/;"	t	file:
Foo	11/unique_ptr.cpp	/^    Foo() { std::cout << "Foo...\\n"; }$/;"	f	struct:Foo
Foo	11/unique_ptr.cpp	/^struct Foo {$/;"	s	file:
Garbo	design_pattern/singleton/Singleton.h	/^    class Garbo \/\/它的唯一的工作就是在析构函数中删除Singleton的实例$/;"	c	class:Singleton
GetChild	design_pattern/composite/Composite.cpp	/^Component* Composite::GetChild(int nIndex)$/;"	f	class:Composite
GetChild	design_pattern/composite/Composite.h	/^    virtual Component* GetChild(int nIndex){return NULL;}\/\/获取子部件的指针$/;"	f	class:Component
GetInstance	design_pattern/singleton/Singleton.cpp	/^Singleton Singleton::GetInstance()$/;"	f	class:Singleton
GetInstancePtr	design_pattern/singleton/Singleton.cpp	/^Singleton* Singleton::GetInstancePtr()$/;"	f	class:Singleton
GetQueHead	test/queue.c	/^int GetQueHead(PT_QUEUE ptQue)$/;"	f
GetQueHeadData	test/queue.c	/^int GetQueHeadData(PT_QUEUE ptQue)$/;"	f
GetQueTail	test/queue.c	/^int GetQueTail(PT_QUEUE ptQue)$/;"	f
GetSize	design_pattern/iterator/Iterator.cpp	/^int ConcreateAggregate::GetSize()$/;"	f	class:ConcreateAggregate
GetState	design_pattern/observer/Observer.cpp	/^STATE ConcreateSubject::GetState()$/;"	f	class:ConcreateSubject
INDENT	test/v.c	11;"	d	file:
INIT_NUM	producer_consumer2.cpp	11;"	d	file:
ITERATOR_H	design_pattern/iterator/Iterator.h	2;"	d
Implementor	design_pattern/bridge/Bridge.h	/^    Implementor(){}$/;"	f	class:Implementor
Implementor	design_pattern/bridge/Bridge.h	/^class Implementor$/;"	c
InitColleage	design_pattern/mediator/Mediator.h	/^    void InitColleage(ColleagueA* tempA,ColleagueB* tempB)$/;"	f	class:ConcreteMediator
InitQue	test/queue.c	/^void InitQue(PT_QUEUE ptQue)$/;"	f
IsQueEmpty	test/queue.c	/^int IsQueEmpty(PT_QUEUE ptQue)$/;"	f
IsQueFull	test/queue.c	/^int IsQueFull(PT_QUEUE ptQue)$/;"	f
Iterater	design_pattern/iterator/Iterator.h	/^class Iterater$/;"	c
KEY	net/socket_server.c	13;"	d	file:
Leaf	design_pattern/composite/Composite.h	/^    Leaf(string strParam):Component(strParam){}$/;"	f	class:Leaf
Leaf	design_pattern/composite/Composite.h	/^class Leaf  : public Component$/;"	c
LeaveQue	test/queue.c	/^int LeaveQue(PT_QUEUE ptQue)$/;"	f
MAXBUF	net/epoll_server.c	19;"	d	file:
MAXBUF	net/select_client.c	13;"	d	file:
MAXBUF	net/select_server.c	14;"	d	file:
MAXDATASIZE	net/socket_client.c	14;"	d	file:
MAXEPOLLSIZE	net/epoll_server.c	20;"	d	file:
MAXEVENTS	net/epoll_test.c	11;"	d	file:
MAXLINE	test/eval.c	5;"	d	file:
MAXLINE	test/popen/filter.c	4;"	d	file:
MAX_COLOR	lua/main.c	9;"	d	file:
MAX_EVENT_NUMBER	test/tick.c	18;"	d	file:
MSG_FILE	net/recv.c	10;"	d	file:
MSG_FILE	net/send.c	9;"	d	file:
Mediator	design_pattern/mediator/Mediator.h	/^class Mediator$/;"	c
Message_Queue	test/pd.cpp	/^    Message_Queue():_nready(0)$/;"	f	class:Message_Queue
Message_Queue	test/pd.cpp	/^class Message_Queue$/;"	c	file:
N	thread/thread_test.c	/^const int N = 10000;$/;"	v
Node	avl_tree.h	/^        Node(Type _e):e(_e),left(NULL),right(NULL),h(0){}$/;"	f	struct:AVLTree::Node
Node	avl_tree.h	/^        Node(Type _e,Node* _left,Node* _right,int _h):e(e),left(_left),right(_right),h(_h){}$/;"	f	struct:AVLTree::Node
Node	avl_tree.h	/^    struct Node$/;"	s	class:AVLTree
NonCopyable	test/a.cpp	/^    NonCopyable(){};$/;"	f	class:NonCopyable
NonCopyable	test/a.cpp	/^class NonCopyable$/;"	c	file:
Notify	design_pattern/mediator/Mediator.h	/^    void Notify(string strMsg)$/;"	f	class:ColleagueA
Notify	design_pattern/mediator/Mediator.h	/^    void Notify(string strMsg)$/;"	f	class:ColleagueB
Notify	design_pattern/observer/Observer.cpp	/^void Subject::Notify()$/;"	f	class:Subject
OBSERVER_H	design_pattern/observer/Observer.h	2;"	d
ONE	static_cast.cpp	/^enum EU { ONE, TWO, THREE };$/;"	e	enum:EU	file:
ONE	static_cast.cpp	/^enum class E { ONE, TWO, THREE };$/;"	m	class:E	file:
OP	test/v.c	12;"	d	file:
Observer	design_pattern/observer/Observer.h	/^    Observer() : m_nObserverState(-1){}$/;"	f	class:Observer
Observer	design_pattern/observer/Observer.h	/^class Observer$/;"	c
Operation	design_pattern/bridge/Bridge.cpp	/^void Abstraction::Operation()$/;"	f	class:Abstraction
Operation	design_pattern/composite/Composite.cpp	/^void Composite::Operation()$/;"	f	class:Composite
Operation	design_pattern/composite/Composite.cpp	/^void Leaf::Operation()$/;"	f	class:Leaf
Operation	design_pattern/decorator/Decorator.cpp	/^void ConcreateComponent::Operation()$/;"	f	class:ConcreateComponent
Operation	design_pattern/decorator/Decorator.cpp	/^void ConcreateDecorator::Operation()$/;"	f	class:ConcreateDecorator
OperationImpl	design_pattern/bridge/Bridge.cpp	/^void ConcreateImplementorA::OperationImpl()$/;"	f	class:ConcreateImplementorA
OperationImpl	design_pattern/bridge/Bridge.cpp	/^void ConcreateImplementorB::OperationImpl()$/;"	f	class:ConcreateImplementorB
PERM	net/recv.c	12;"	d	file:
PERM	net/send.c	11;"	d	file:
PORT	net/socket_server.c	12;"	d	file:
PRD_NUM	test/queue.c	8;"	d	file:
PRODUCER_NUM	test/queue.c	6;"	d	file:
PRODUCT_SPEED	producer_consumer2.cpp	9;"	d	file:
PROXY_H	design_pattern/proxy/Proxy.h	2;"	d
PT_QUEUE	test/queue.c	/^}T_QUEUE, *PT_QUEUE;$/;"	t	typeref:struct:__anon1	file:
Poll	net/reactor.cpp	/^void Poller::Poll(int timeoutMs,ChannelList* activeChannels) {$/;"	f	class:Poller
PollFdList	net/reactor.cpp	/^    typedef vector<struct pollfd> PollFdList;\/\/struct pollfd是poll系统调用监听的事件集合参数$/;"	t	class:Poller	file:
Poller	net/reactor.cpp	/^Poller::Poller(EventLoop* loop):ownerLoop_(loop){}\/\/Poller明确所属的EventLoop$/;"	f	class:Poller
Poller	net/reactor.cpp	/^class Poller:noncopyable{$/;"	c	file:
PrintIntDeque	test/deque.cpp	/^    void PrintIntDeque(std::deque<int>& deq, char* pre) {$/;"	f	namespace:ClassFoo
ProducerThread	test/queue.c	/^void *ProducerThread(void *pvArg)$/;"	f
Proxy	design_pattern/proxy/Proxy.cpp	/^Proxy::Proxy() : m_pRealSubject(NULL)$/;"	f	class:Proxy
Proxy	design_pattern/proxy/Proxy.h	/^class Proxy : public Subject$/;"	c
QUEUE_SIZE	test/queue.c	10;"	d	file:
QueDataNum	test/queue.c	/^int QueDataNum(PT_QUEUE ptQue)$/;"	f
ReadPipe	net/reactor.cpp	/^void ReadPipe(){$/;"	f
ReadTableFromIndex	lua/lua_test.c	/^static void ReadTableFromIndex(lua_State *L, const char* lpszTableName, int index)  $/;"	f	file:
ReadTableFromItem	lua/lua_test.c	/^static void ReadTableFromItem(lua_State *L, const char* lpszTableName, const char* lpszTableItem)  $/;"	f	file:
ReadVariable	lua/lua_test.c	/^void ReadVariable (lua_State *L,int *width,int *height){  $/;"	f
RealSubject	design_pattern/proxy/Proxy.cpp	/^RealSubject::RealSubject()$/;"	f	class:RealSubject
RealSubject	design_pattern/proxy/Proxy.h	/^class RealSubject : public Subject$/;"	c
Remove	design_pattern/composite/Composite.cpp	/^void Composite::Remove(Component* pChild)$/;"	f	class:Composite
Remove	design_pattern/composite/Composite.h	/^    virtual void Remove(Component* pChild){}\/\/删除一个子部件$/;"	f	class:Component
Request	design_pattern/proxy/Proxy.cpp	/^void Proxy::Request()$/;"	f	class:Proxy
Request	design_pattern/proxy/Proxy.cpp	/^void RealSubject::Request()$/;"	f	class:RealSubject
SERVER_IP	net/socket_client.c	15;"	d	file:
SERVER_PORT	net/socket_client.c	12;"	d	file:
SINGLETON_H	design_pattern/singleton/Singleton.h	2;"	d
SIZE	net/socket_server.c	14;"	d	file:
STATE	design_pattern/observer/Observer.h	/^typedef int STATE;$/;"	t
ScopeMutex	test/a.cpp	/^    ScopeMutex(pthread_mutex_t* mutex):mutex_(mutex){$/;"	f	class:ScopeMutex
ScopeMutex	test/a.cpp	/^class ScopeMutex:NonCopyable$/;"	c	file:
Send	design_pattern/mediator/Mediator.h	/^    virtual void Send(string msg,Colleague* col)$/;"	f	class:ConcreteMediator
Send	design_pattern/mediator/Mediator.h	/^    void Send(string strMsg)$/;"	f	class:ColleagueA
Send	design_pattern/mediator/Mediator.h	/^    void Send(string strMsg)$/;"	f	class:ColleagueB
SetState	design_pattern/observer/Observer.cpp	/^void ConcreateSubject::SetState(STATE nState)$/;"	f	class:ConcreateSubject
Singleton	design_pattern/singleton/Singleton.h	/^    Singleton(){};$/;"	f	class:Singleton
Singleton	design_pattern/singleton/Singleton.h	/^class Singleton$/;"	c
Subject	design_pattern/observer/Observer.h	/^    Subject() : m_nSubjectState(-1){}$/;"	f	class:Subject
Subject	design_pattern/observer/Observer.h	/^class Subject$/;"	c
Subject	design_pattern/proxy/Proxy.h	/^    Subject(){}$/;"	f	class:Subject
Subject	design_pattern/proxy/Proxy.h	/^class Subject$/;"	c
SuccessPrint	boost/fun2.cpp	/^typedef boost::function<void (int)> SuccessPrint;$/;"	t	file:
THREAD_NUMBER	thread/3_thread.c	/^const int THREAD_NUMBER = 3;$/;"	v
THREE	static_cast.cpp	/^enum EU { ONE, TWO, THREE };$/;"	e	enum:EU	file:
TIMESLOT	test/tick.c	19;"	d	file:
TOTAL_NUM	producer_consumer2.cpp	12;"	d	file:
TWO	static_cast.cpp	/^enum EU { ONE, TWO, THREE };$/;"	e	enum:EU	file:
TWO	static_cast.cpp	/^enum class E { ONE, TWO, THREE };$/;"	m	class:E	file:
T_QUEUE	test/queue.c	/^}T_QUEUE, *PT_QUEUE;$/;"	t	typeref:struct:__anon1	file:
Test	design_pattern/singleton/Singleton.cpp	/^void Singleton::Test()$/;"	f	class:Singleton
ThreadFunc	thread/4_thread.cpp	/^void *ThreadFunc(void *arg)$/;"	f
Update	design_pattern/observer/Observer.cpp	/^void ConcreateObserver::Update(Subject* pSubject)$/;"	f	class:ConcreateObserver
_cond	test/pd.cpp	/^    pthread_cond_t     _cond;$/;"	m	class:Message_Queue	file:
_mutex	test/pd.cpp	/^    pthread_mutex_t     _mutex;$/;"	m	class:Message_Queue	file:
_nready	test/pd.cpp	/^    int                 _nready;$/;"	m	class:Message_Queue	file:
_queue	test/pd.cpp	/^    deque<DataType> _queue;$/;"	m	class:Message_Queue	file:
_ready_mutex	test/pd.cpp	/^    pthread_mutex_t     _ready_mutex;$/;"	m	class:Message_Queue	file:
_swap	thread/lock.cpp	/^void _swap(test& a,test& b){$/;"	f
_test	test/switch.c	/^void *_test(void *arg)$/;"	f
a	thread/lock.cpp	/^test a,b;$/;"	v
a	thread/thread_race.cpp	/^        int *a;$/;"	m	class:test	file:
aData	test/queue.c	/^    int aData[QUEUE_SIZE];  \/\/队列元素$/;"	m	struct:__anon1	file:
abortNotInLoopThread	net/reactor.cpp	/^void EventLoop::abortNotInLoopThread() {$/;"	f	class:EventLoop
activeChannels_	net/reactor.cpp	/^    ChannelList activeChannels_;\/\/类似与poll的就绪事件集合，这里集合换成Channel(事件分发器具备就绪事件回调功能)$/;"	m	class:EventLoop	file:
add	typedef.c	/^int add(int a, int b)$/;"	f
addThread	test/cthreadpoolmanage.cpp	/^int CthreadPoolManage::addThread(std::list< CthreadPoolManage::threadInfo* >* plist, CthreadPoolManage::threadInfo* ptinfo)$/;"	f	class:CthreadPoolManage
add_observer	boost/boost_fun.cpp	/^    void add_observer(function_type t) {$/;"	f	class:notifier
add_to_lib	producer_consumer2.cpp	/^int add_to_lib()                                \/\/添加产品到仓库$/;"	f
addfd	test/tick.c	/^void addfd( int epollfd, int fd )\/\/添加描述符到事件表$/;"	f
addsig	test/tick.c	/^void addsig( int sig )\/\/安装信号处理函数，sig为信号$/;"	f
assertInLoopThread	net/reactor.cpp	/^    void assertInLoopThread(){\/\/判定是否和EventLoop的隶属关系，EventLoop要拥有此Poller$/;"	f	class:Poller
assertInLoopThread	net/reactor.cpp	/^    void assertInLoopThread(){\/\/若运行线程不拥有EventLoop则退出，保证one loop per thread$/;"	f	class:EventLoop
b	thread/lock.cpp	/^test a,b;$/;"	v
buffer	producer_consumer.cpp	/^int buffer[BUFFER_LENGTH];$/;"	v
buffer	test/producer_consumer.c	/^int buffer[BUFFER_LENGTH];$/;"	v
buffer	test/switch.c	/^char buffer[10];$/;"	v
c	test/pd.cpp	/^const int c = 2;$/;"	v
c_sem	producer_consumer2.cpp	/^sem_t p_sem, c_sem, sh_sem;$/;"	v
calc	typedef.c	/^int calc(int a, int b, char op)  $/;"	f
calc_func	typedef.c	/^FP_CALC calc_func(char op)$/;"	f
cb_func	test/tick.c	/^void cb_func( client_data* user_data )\/\/超时连接处理逻辑$/;"	f
change_value	boost/boost_fun.cpp	/^    void change_value(int i) {$/;"	f	class:notifier
channels_	net/reactor.cpp	/^    ChannelMap channels_;\/\/文件描述符fd到Channel的映射$/;"	m	class:Poller	file:
checkThread	test/cthreadpoolmanage.cpp	/^void* CthreadPoolManage::checkThread(void* arg)$/;"	f	class:CthreadPoolManage
clear	avl_tree.h	/^template<typename Type> void AVLTree<Type>::clear()$/;"	f	class:AVLTree
clears	avl_tree.h	/^template<typename Type> void AVLTree<Type>::clears(Node*& p)$/;"	f	class:AVLTree
cmd	thread/thread_test.c	/^const char *cmd = "";$/;"	v
colA	design_pattern/mediator/Mediator.h	/^    ColleagueA* colA;$/;"	m	class:ConcreteMediator
colB	design_pattern/mediator/Mediator.h	/^    ColleagueB* colB;$/;"	m	class:ConcreteMediator
combine1	test/v.c	/^void combine1(vec_ptr v, data_t *dest)$/;"	f
compare_nocase	test/list.cpp	/^bool compare_nocase (const std::string& first, const std::string& second)$/;"	f
cond	producer_consumer.cpp	/^pthread_cond_t cond = PTHREAD_COND_INITIALIZER;$/;"	v
cond	test/c.c	/^pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\/*初始化条件变量*\/$/;"	v
cond	thread/thread.c	/^pthread_cond_t cond;$/;"	v
cond	thread/time_wait.c	/^pthread_cond_t cond;$/;"	v
consum	producer_consumer2.cpp	/^void consum()                                       \/\/消费$/;"	f
consume	test/pd.cpp	/^void *consume(void *arg) \/\/消费者线程$/;"	f
consumer	producer_consumer.cpp	/^void *consumer(void *arg)$/;"	f
consumer	producer_consumer2.cpp	/^void *consumer(void *arg)               \/\/消费者线程$/;"	f
consumer	test/producer_consumer.c	/^void *consumer(void *arg)$/;"	f
consumer_wait	test/producer_consumer.c	/^bool consumer_wait = false;$/;"	v
count	sync_add.c	/^static int count = 0;$/;"	v	file:
counter	test/a.cpp	/^int counter = 0;$/;"	v
create_and_bind	net/epoll_test.c	/^static int create_and_bind (char *port)$/;"	f	file:
data	test/v.c	/^    data_t *data;$/;"	m	struct:__anon2	file:
data_t	test/v.c	/^typedef int data_t;$/;"	t	file:
distroy	test/switch.c	/^void distroy()$/;"	f
dwHead	test/queue.c	/^    int dwHead;  \/\/指向队首元素$/;"	m	struct:__anon1	file:
dwTail	test/queue.c	/^    int dwTail;  \/\/指向队尾元素的下一个元素$/;"	m	struct:__anon1	file:
e	avl_tree.h	/^        Type e;$/;"	m	struct:AVLTree::Node
efd	net/eventfd.c	/^int efd = -1;$/;"	v
empty	avl_tree.h	/^    bool empty(){return mRoot==NULL;};$/;"	f	class:AVLTree
empty_cond	test/producer_consumer.c	/^pthread_cond_t empty_cond = PTHREAD_COND_INITIALIZER;$/;"	v
enableReading	net/reactor.cpp	/^    void enableReading(){\/\/fd注册可读事件$/;"	f	class:Channel
enableWriting	net/reactor.cpp	/^    void enableWriting(){\/\/fd注册可写事件$/;"	f	class:Channel
epollfd	test/tick.c	/^static int epollfd = 0;\/\/epoll事件表描述符$/;"	v	file:
erase	avl_tree.h	/^template<typename Type> void AVLTree<Type>::erase(Type e,Node* &p)$/;"	f	class:AVLTree
errorCallback	net/reactor.cpp	/^    EventCallback errorCallback;\/\/出错事件回调函数$/;"	m	class:Channel	file:
events	net/reactor.cpp	/^    int events() const{return events_;}\/\/返回fd域注册的事件类型$/;"	f	class:Channel
events_	net/reactor.cpp	/^    int events_;\/\/fd_注册的事件$/;"	m	class:Channel	file:
f	11/weak_ptr2.cpp	/^void f()$/;"	f
f	boost/bind.cpp	/^void  f(int  a, int  b)$/;"	f
f	lua/lua.lua	/^function f(x, y)$/;"	f
fd	net/close-shutdown.c	/^int fd;$/;"	v
fd	net/reactor.cpp	/^    int fd() const{return fd_;}\/\/返回Channel负责的文件描述符fd，即建立Channel到fd的映射$/;"	f	class:Channel
fd_	net/reactor.cpp	/^    const int fd_;\/\/每个Channel唯一负责的文件描述符，Channel不拥有fd$/;"	m	class:Channel	file:
fillActiveChannels	net/reactor.cpp	/^void Poller::fillActiveChannels(int numEvents,ChannelList* activeChannels) const{\/\/将就绪事件通过activeChannels返回$/;"	f	class:Poller
fill_list	test/any.cpp	/^void fill_list(list_any &la)$/;"	f
find	avl_tree.h	/^template<typename Type> typename AVLTree<Type>::Node*& AVLTree<Type>::find(Type e)const$/;"	f	class:AVLTree
flag	thread/time_wait.c	/^unsigned char flag = 1;$/;"	v
foo	boost/boost_python/simple.py	/^def foo(i = 4):$/;"	f
front	producer_consumer.cpp	/^int front = 0, rear = -1;$/;"	v
front	test/producer_consumer.c	/^int front = 0, rear = -1; \/\/ 缓冲区的前端和尾端$/;"	v
full_cond	test/producer_consumer.c	/^pthread_cond_t full_cond = PTHREAD_COND_INITIALIZER;$/;"	v
fun	thread.cpp	/^void* fun(void* v)$/;"	f
func	lua/main.c	/^double func(lua_State *L, double x, double y)$/;"	f
func1	boost/fun.cpp	/^int func1(int i) { return (i*5); }$/;"	f
func2	boost/fun.cpp	/^bool func2(int i, double d) { return (i > d); }$/;"	f
function_type	boost/boost_fun.cpp	/^    typedef void (*function_type)(int);$/;"	t	class:notifier	file:
g	boost/bind.cpp	/^void  g(int  a, int  b, int  c)$/;"	f
getLength	avl_tree.h	/^    int  getLength(){return mLength;}$/;"	f	class:AVLTree
getNowThreadNum	test/cthreadpoolmanage.cpp	/^int CthreadPoolManage::getNowThreadNum()$/;"	f	class:CthreadPoolManage
getParent	avl_tree.h	/^template<typename Type> typename AVLTree<Type>::Node* & AVLTree<Type>::getParent(Node* p)$/;"	f	class:AVLTree
getRoot	avl_tree.h	/^    Node*& getRoot(){return mRoot;} \/\/notice the return type$/;"	f	class:AVLTree
get_color_field	lua/main.c	/^int get_color_field(lua_State *L, const char *key)$/;"	f
get_msg	test/pd.cpp	/^    int get_msg(DataType &d)$/;"	f	class:Message_Queue
get_perms	test/my_perms.cpp	/^vector<string>get_perms(string str)$/;"	f
get_vec_element	test/v.c	/^int get_vec_element(vec_ptr v, long int index, data_t *dest)$/;"	f
glFun	typedef.c	/^char glFun(int a) { return a; }$/;"	f
gtCsmCond	test/queue.c	/^pthread_cond_t gtCsmCond = PTHREAD_COND_INITIALIZER; \/\/Empty->Not Empty$/;"	v
gtPrdCond	test/queue.c	/^pthread_cond_t gtPrdCond = PTHREAD_COND_INITIALIZER; \/\/Full->Not Full$/;"	v
gtQueLock	test/queue.c	/^pthread_mutex_t gtQueLock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
gtQueue	test/queue.c	/^T_QUEUE gtQueue;$/;"	v
gw	11/weak_ptr2.cpp	/^std::weak_ptr<int> gw;$/;"	v
h	avl_tree.h	/^        int h;$/;"	m	struct:AVLTree::Node
handleEvent	net/reactor.cpp	/^void Channel::handleEvent(){\/\/处理就绪事件的处理函数$/;"	f	class:Channel
handle_message	net/epoll_server.c	/^int handle_message(int new_fd)$/;"	f
height	avl_tree.h	/^    int  height(Node* p)const{ return p == NULL ? -1 : p->h ;}$/;"	f	class:AVLTree
i	test/c.c	/^int i=1;$/;"	v
index	net/reactor.cpp	/^    int index(){return index_;}\/\/index_是本Channel负责的fd在poll监听事件集合的下标，用于快速索引到fd的pollfd$/;"	f	class:Channel
index_	net/reactor.cpp	/^    int index_;\/\/在poll的监听事件集合pollfd的下标，用于快速索引到fd的pollfd$/;"	m	class:Channel	file:
initThread	test/cthreadpoolmanage.cpp	/^void CthreadPoolManage::initThread()$/;"	f	class:CthreadPoolManage
init_daemon	test/daemon_test.c	/^void init_daemon(void)$/;"	f
insert	avl_tree.h	/^template<typename Type> bool AVLTree<Type>::insert(Type e,Node* &p)$/;"	f	class:AVLTree
insert_char_at	test/my_perms.cpp	/^string insert_char_at(string word, char c, int i)$/;"	f
interested_in_the_change	boost/boost_fun.cpp	/^void interested_in_the_change(int i) {$/;"	f
inti	test/switch.c	/^void inti()$/;"	f
isInLoopThread	net/reactor.cpp	/^    bool isInLoopThread() const{return threadID_==syscall(SYS_gettid);}\/\/判断运行线程是否为拥有此EventLoop的线程$/;"	f	class:EventLoop
isInitialized	boost/boost_python/pyinit.hpp	/^    bool isInitialized() {$/;"	f	class:pyinit
isNoneEvent	net/reactor.cpp	/^    bool isNoneEvent() const{\/\/fd没有想要注册的事件$/;"	f	class:Channel
kNoneEvent	net/reactor.cpp	/^    static const int kNoneEvent;\/\/无任何事件$/;"	m	class:Channel	file:
kNoneEvent	net/reactor.cpp	/^const int Channel::kNoneEvent=0;\/\/无事件$/;"	m	class:Channel	file:
kPollTimeMs	net/reactor.cpp	/^const int kPollTimeMs=10000;\/\/poll等待时间$/;"	v
kReadEvent	net/reactor.cpp	/^    static const int kReadEvent;\/\/可读事件$/;"	m	class:Channel	file:
kReadEvent	net/reactor.cpp	/^const int Channel::kReadEvent=POLLIN|POLLPRI;\/\/可读事件$/;"	m	class:Channel	file:
kWriteEvent	net/reactor.cpp	/^    static const int kWriteEvent;\/\/可写事件$/;"	m	class:Channel	file:
kWriteEvent	net/reactor.cpp	/^const int Channel::kWriteEvent=POLLOUT;\/\/可写事件$/;"	m	class:Channel	file:
left	avl_tree.h	/^        Node* left;$/;"	m	struct:AVLTree::Node
len	test/v.c	/^    long int len;$/;"	m	struct:__anon2	file:
list_any	test/any.cpp	/^typedef std::list<boost::any> list_any;$/;"	t	file:
listen_thread	test/pipe.cpp	/^void * listen_thread(void *arg)$/;"	f
lock	thread/lock.cpp	/^        void lock(){$/;"	f	class:test
loop	net/reactor.cpp	/^EventLoop* loop;$/;"	v
loop	net/reactor.cpp	/^void EventLoop::loop() {\/\/EventLoop主循环，主要功能是监听事件集合，执行就绪事件的处理函数$/;"	f	class:EventLoop
loop_	net/reactor.cpp	/^    EventLoop* loop_;\/\/Channel隶属的EventLoop(原则上EventLoop，Poller，Channel都是一个IO线程)$/;"	m	class:Channel	file:
looping_	net/reactor.cpp	/^    bool looping_;\/\/事件循环主体loop是运行标志$/;"	m	class:EventLoop	file:
mGarbo	design_pattern/singleton/Singleton.h	/^    static Garbo mGarbo;\/\/定义一个静态成员，在程序结束的时候，系统会调用它的析构函数$/;"	m	class:Singleton
mLength	avl_tree.h	/^    int mLength;$/;"	m	class:AVLTree
mRoot	avl_tree.h	/^    Node* mRoot;$/;"	m	class:AVLTree
m_ListObserver	design_pattern/observer/Observer.h	/^    std::list<Observer*>    m_ListObserver; \/\/ 保存Observer指针的链表$/;"	m	class:Subject
m_ListOfComponent	design_pattern/composite/Composite.h	/^    std::list<Component*>   m_ListOfComponent;$/;"	m	class:Composite
m_nIndex	design_pattern/iterator/Iterator.h	/^    int         m_nIndex;$/;"	m	class:ConcreateIterater
m_nObserverState	design_pattern/observer/Observer.h	/^    STATE m_nObserverState;                 \/\/ 模拟保存Observer状态的变量$/;"	m	class:Observer
m_nSize	design_pattern/iterator/Iterator.h	/^    int m_nSize;$/;"	m	class:ConcreateAggregate
m_nSubjectState	design_pattern/observer/Observer.h	/^    STATE m_nSubjectState;                  \/\/ 模拟保存Subject状态的变量$/;"	m	class:Subject
m_pBuilder	design_pattern/build/Builder.h	/^    Builder* m_pBuilder;$/;"	m	class:Director
m_pComponent	design_pattern/decorator/Decorator.h	/^    Component* m_pComponent;$/;"	m	class:Decorator
m_pConcreateAggregate	design_pattern/iterator/Iterator.h	/^    Aggregate  *m_pConcreateAggregate;$/;"	m	class:ConcreateIterater
m_pData	design_pattern/iterator/Iterator.h	/^    DATA *m_pData;$/;"	m	class:ConcreateAggregate
m_pImplementor	design_pattern/bridge/Bridge.h	/^    Implementor* m_pImplementor;$/;"	m	class:Abstraction
m_pRealSubject	design_pattern/proxy/Proxy.h	/^    RealSubject* m_pRealSubject;$/;"	m	class:Proxy
m_pStatic	design_pattern/singleton/Singleton.cpp	/^Singleton* Singleton::m_pStatic = NULL;\/\/定义并初始化$/;"	m	class:Singleton	file:
m_pStatic	design_pattern/singleton/Singleton.h	/^    static Singleton* m_pStatic;\/\/ 静态成员变量,提供全局惟一的一个实例$/;"	m	class:Singleton
m_strName	design_pattern/composite/Composite.h	/^    string m_strName;$/;"	m	class:Component
main	11/regex_match.cpp	/^int main ()$/;"	f
main	11/share_ptr.cpp	/^int main()$/;"	f
main	11/unique_ptr.cpp	/^int main()$/;"	f
main	11/weak_ptr2.cpp	/^int main()$/;"	f
main	avl_test.cpp	/^int main()$/;"	f
main	boost/bind.cpp	/^int  main()$/;"	f
main	boost/boost_fun.cpp	/^int main() {$/;"	f
main	boost/boost_python/boost_python.cpp	/^int main()$/;"	f
main	boost/enable_shared_from_this.cpp	/^int main()$/;"	f
main	boost/fun.cpp	/^int main()$/;"	f
main	boost/fun2.cpp	/^int main() $/;"	f
main	boost/regex/match.cpp	/^int main()$/;"	f
main	boost/regex/regex_test.cpp	/^int main(int argc, char* argv[])$/;"	f
main	boost/regex/search.cpp	/^int main() {$/;"	f
main	boost/scope_ptr.cpp	/^int main()$/;"	f
main	boost/weak_ptr.cpp	/^int main()$/;"	f
main	design_pattern/bridge/main.cpp	/^int main()$/;"	f
main	design_pattern/build/main.cpp	/^int main()$/;"	f
main	design_pattern/build/test.c	/^int main ()$/;"	f
main	design_pattern/composite/main.cpp	/^int main()$/;"	f
main	design_pattern/decorator/main.cpp	/^int main()$/;"	f
main	design_pattern/iterator/main.cpp	/^int main()$/;"	f
main	design_pattern/mediator/main.cpp	/^int main()$/;"	f
main	design_pattern/observer/main.cpp	/^int main()$/;"	f
main	design_pattern/proxy/main.cpp	/^int main()$/;"	f
main	design_pattern/singleton/main.cpp	/^int main()$/;"	f
main	get_date.cpp	/^int main()$/;"	f
main	lua/lua_test.c	/^int main(int argc, char* argv[])  $/;"	f
main	lua/main.c	/^int main ()$/;"	f
main	move.cpp	/^int main () {$/;"	f
main	net/close-shutdown.c	/^int main( int argc, char **argv )$/;"	f
main	net/epoll_server.c	/^int main(int argc, char **argv)$/;"	f
main	net/epoll_test.c	/^int main (int argc, char *argv[])$/;"	f
main	net/eventfd.c	/^int main(int argc, char *argv[])$/;"	f
main	net/reactor.cpp	/^int main(){$/;"	f
main	net/recv.c	/^int main()$/;"	f
main	net/select_client.c	/^int main(int argc, char **argv)$/;"	f
main	net/select_server.c	/^int main(int argc, char **argv)$/;"	f
main	net/send.c	/^int main()$/;"	f
main	net/socket_client.c	/^int main() { $/;"	f
main	net/socket_server.c	/^int main()$/;"	f
main	peek.cpp	/^int main () {$/;"	f
main	producer_consumer.cpp	/^int main(int argc, char **argv)$/;"	f
main	producer_consumer2.cpp	/^int main()$/;"	f
main	putback.cpp	/^int main () {$/;"	f
main	static_cast.cpp	/^int main()$/;"	f
main	stream/clear.cpp	/^int main () {$/;"	f
main	stream/io.cpp	/^int main()$/;"	f
main	stream/stream_test.cpp	/^int main()$/;"	f
main	string/assign.cpp	/^int main ()$/;"	f
main	string/erase.cpp	/^int main ()$/;"	f
main	sync_add.c	/^int main(int argc, const char *argv[])$/;"	f
main	syslog.c	/^int main(int argc, char * argv[])$/;"	f
main	test/a.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/any.cpp	/^int main()$/;"	f
main	test/b.c	/^int main()$/;"	f
main	test/c.c	/^int main(void)$/;"	f
main	test/daemon_test.c	/^int main()$/;"	f
main	test/deque.cpp	/^int main(void)$/;"	f
main	test/eval.c	/^int main()$/;"	f
main	test/getline.c	/^int main()$/;"	f
main	test/heap.cpp	/^int main () {$/;"	f
main	test/list.cpp	/^int main ()$/;"	f
main	test/my_perms.cpp	/^int main()$/;"	f
main	test/pair.cpp	/^int main () {$/;"	f
main	test/pd.cpp	/^int main()$/;"	f
main	test/pipe.cpp	/^int main(int argc, char** argv)$/;"	f
main	test/pipe/pipe_test.c	/^int main(int argc, char *argv[])$/;"	f
main	test/pipe/socket_pair.cpp	/^int main(void) {$/;"	f
main	test/popen/filter.c	/^int main()$/;"	f
main	test/popen/myuclc.c	/^int main()$/;"	f
main	test/priority_queue.cpp	/^int main()$/;"	f
main	test/producer_consumer.c	/^int main(int argc, char **argv)$/;"	f
main	test/queue.c	/^int main(void)$/;"	f
main	test/set.cpp	/^int main ()$/;"	f
main	test/share_ptr.cpp	/^int main()  $/;"	f
main	test/switch.c	/^int main()$/;"	f
main	test/test.cpp	/^int main () {$/;"	f
main	test/tick.c	/^int main( int argc, char* argv[] )$/;"	f
main	test/v.c	/^int main()$/;"	f
main	test/weak_ptr.cpp	/^int main() $/;"	f
main	thread.cpp	/^int main()$/;"	f
main	thread/3_thread.c	/^int main(int argc, char **argv)$/;"	f
main	thread/4_thread.cpp	/^int  main(int argc, char const *argv[])$/;"	f
main	thread/lock.cpp	/^int main() {$/;"	f
main	thread/once.c	/^int main(int argc,char** argv)$/;"	f
main	thread/thread.c	/^int main(int argc, char **argv)$/;"	f
main	thread/thread_race.cpp	/^int main(){$/;"	f
main	thread/thread_test.c	/^int main(int argc, char *argv[])$/;"	f
main	thread/time_wait.c	/^int main()$/;"	f
main	typedef.c	/^int main()$/;"	f
main	unget.cpp	/^int main () {$/;"	f
main	write.c	/^int main()$/;"	f
main_count	thread/thread.c	/^int main_count = 0;$/;"	v
main_thread_func	thread/thread.c	/^void main_thread_func()$/;"	f
main_thread_wait_flag	thread/thread.c	/^bool main_thread_wait_flag = false;$/;"	v
make_socket_non_blocking	net/epoll_test.c	/^static int make_socket_non_blocking (int sfd)$/;"	f	file:
max	avl_tree.h	/^    int  max(int x,int y){return x>y?x:y;}$/;"	f	class:AVLTree
mediator	design_pattern/mediator/Mediator.h	/^    Mediator* mediator;$/;"	m	class:Colleague
message	net/send.c	/^char *message[3]={"I'm sender,there are some message for you.","Message1",$/;"	v
msgbuf	net/recv.c	/^struct msgbuf$/;"	s	file:
msgbuf	net/send.c	/^struct msgbuf$/;"	s	file:
msleep	producer_consumer2.cpp	8;"	d	file:
mtext	net/recv.c	/^    char mtext[BUFFER+1];$/;"	m	struct:msgbuf	file:
mtext	net/send.c	/^    char mtext[BUFFER_SIZE+1];$/;"	m	struct:msgbuf	file:
mtype	net/recv.c	/^    long mtype;$/;"	m	struct:msgbuf	file:
mtype	net/send.c	/^    long mtype;$/;"	m	struct:msgbuf	file:
mutex	producer_consumer.cpp	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	test/a.cpp	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	test/c.c	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\/*初始化互斥锁*\/$/;"	v
mutex	test/producer_consumer.c	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	thread/3_thread.c	/^pthread_mutex_t mutex;$/;"	v
mutex	thread/lock.cpp	/^        pthread_mutex_t mutex;$/;"	m	class:test	file:
mutex	thread/thread.c	/^pthread_mutex_t mutex;$/;"	v
mutex	thread/time_wait.c	/^pthread_mutex_t mutex;$/;"	v
mutex_	test/a.cpp	/^    pthread_mutex_t *mutex_;$/;"	m	class:ScopeMutex	file:
my_perms	test/my_perms.cpp	/^void my_perms(char *str)$/;"	f
my_perms	test/my_perms.cpp	/^void my_perms(char *str, char *p_begin)$/;"	f
mycond	thread/4_thread.cpp	/^pthread_cond_t mycond = PTHREAD_COND_INITIALIZER;$/;"	v
n	thread/4_thread.cpp	/^int n = 0;$/;"	v
new_vec	test/v.c	/^vec_ptr new_vec(long int len)$/;"	f
notifier	boost/boost_fun.cpp	/^class notifier {$/;"	c	file:
num	producer_consumer2.cpp	/^int num=INIT_NUM;$/;"	v
once	thread/once.c	/^pthread_once_t  once = PTHREAD_ONCE_INIT;$/;"	v
once_run	thread/once.c	/^void once_run(void)$/;"	f
operator ()	11/unique_ptr.cpp	/^    void operator() (Foo* p) {$/;"	f	struct:D
ownerLoop	net/reactor.cpp	/^    EventLoop* ownerLoop(){return loop_;}$/;"	f	class:Channel
ownerLoop_	net/reactor.cpp	/^    EventLoop* ownerLoop_;\/\/隶属的EventLoop$/;"	m	class:Poller	file:
p	test/pd.cpp	/^const int p = 3;$/;"	v
pFun	typedef.c	/^char (*pFun)(int);$/;"	v
p_sem	producer_consumer2.cpp	/^sem_t p_sem, c_sem, sh_sem;$/;"	v
pipe_fd_work	test/pipe.cpp	/^int pipe_fd_work[2];$/;"	v
pipefd	net/reactor.cpp	/^int pipefd[2];$/;"	v
pipefd	test/tick.c	/^static int pipefd[2];\/\/管道描述符用于将信号处理为统一事件源$/;"	v	file:
pipes	test/switch.c	/^int pipes[20][3];$/;"	v
poller_	net/reactor.cpp	/^    scoped_ptr<Poller> poller_;\/\/IO复用器Poller用于监听事件集合$/;"	m	class:EventLoop	file:
pollfds_	net/reactor.cpp	/^    PollFdList pollfds_;\/\/监听事件集合$/;"	m	class:Poller	file:
print	boost/enable_shared_from_this.cpp	/^    void print()$/;"	f	class:self_shared
print	boost/fun2.cpp	/^void print(int a) $/;"	f
print	test/weak_ptr.cpp	/^DWORD WINAPI print(LPVOID p) $/;"	f
print_new_value	boost/boost_fun.cpp	/^void print_new_value(int i) {$/;"	f
process_ftp	boost/regex/match.cpp	/^int process_ftp(const char* response, std::string *code, std::string* msg)$/;"	f
produce	test/pd.cpp	/^void *produce(void *arg) \/\/生产者线程$/;"	f
producer	producer_consumer.cpp	/^void *producer(void *arg)$/;"	f
producer	test/producer_consumer.c	/^void *producer(void *arg)$/;"	f
producer_wait	test/producer_consumer.c	/^bool producer_wait = false;$/;"	v
product	producer_consumer2.cpp	/^void product(void)                          \/\/生产产品$/;"	f
productor	producer_consumer2.cpp	/^void *productor(void *arg)          \/\/生产者线程$/;"	f
push_msg	test/pd.cpp	/^    int push_msg(DataType &d)$/;"	f	class:Message_Queue
putDuty	test/cthreadpoolmanage.cpp	/^int CthreadPoolManage::putDuty(CDoit* doit, void* value)$/;"	f	class:CthreadPoolManage
pyinit	boost/boost_python/pyinit.hpp	/^    pyinit(int sigs = 1) {$/;"	f	class:pyinit
pyinit	boost/boost_python/pyinit.hpp	/^class pyinit : boost::noncopyable$/;"	c
quit	net/reactor.cpp	/^void EventLoop::quit(){$/;"	f	class:EventLoop
quit_	net/reactor.cpp	/^    bool quit_;\/\/取消循环主体标志$/;"	m	class:EventLoop	file:
readCallback	net/reactor.cpp	/^    EventCallback readCallback;\/\/可读事件回调函数，当poll返回fd_的可读事件时调用此函数执行相应的事件处理，该函数由用户指定$/;"	m	class:Channel	file:
read_number	lua/main.c	/^int read_number(lua_State *L)$/;"	f
read_table	lua/main.c	/^int read_table(lua_State *L)$/;"	f
read_thread	net/eventfd.c	/^void *read_thread(void *dummy)$/;"	f
rear	producer_consumer.cpp	/^int front = 0, rear = -1;$/;"	v
rear	test/producer_consumer.c	/^int front = 0, rear = -1; \/\/ 缓冲区的前端和尾端$/;"	v
reset	test/weak_ptr.cpp	/^DWORD WINAPI reset(LPVOID p) $/;"	f
revents_	net/reactor.cpp	/^    int revents_;\/\/通过poll返回的就绪事件类型$/;"	m	class:Channel	file:
right	avl_tree.h	/^        Node* right;$/;"	m	struct:AVLTree::Node
rotateLeft	avl_tree.h	/^template<typename Type> void AVLTree<Type>::rotateLeft(Node*& k2)$/;"	f	class:AVLTree
rotateLeftDouble	avl_tree.h	/^template<typename Type> void AVLTree<Type>::rotateLeftDouble(Node*& k3)$/;"	f	class:AVLTree
rotateRight	avl_tree.h	/^template<typename Type> void AVLTree<Type>::rotateRight(Node* &k2)$/;"	f	class:AVLTree
rotateRightDouble	avl_tree.h	/^template<typename Type> void AVLTree<Type>::rotateRightDouble(Node*& k3)$/;"	f	class:AVLTree
routine	test/a.cpp	/^void* routine(void *ptr)$/;"	f
routine	thread/thread_test.c	/^void routine()$/;"	f
running	test/switch.c	/^int running = 1;$/;"	v
s_calc_func	typedef.c	/^int (*s_calc_func(char op)) (int, int)$/;"	f
self_shared	boost/enable_shared_from_this.cpp	/^    self_shared(int n):x(n){}$/;"	f	class:self_shared
self_shared	boost/enable_shared_from_this.cpp	/^class self_shared: public enable_shared_from_this<self_shared>$/;"	c	file:
self_test	test/switch.c	/^double self_test()$/;"	f
setErrorCallback	net/reactor.cpp	/^    void setErrorCallback(const EventCallback& cb){\/\/出错事件回调$/;"	f	class:Channel
setReadCallBack	net/reactor.cpp	/^    void setReadCallBack(const EventCallback& cb){\/\/可读事件回调$/;"	f	class:Channel
setWriteCallback	net/reactor.cpp	/^    void setWriteCallback(const EventCallback& cb){\/\/可写事件回调$/;"	f	class:Channel
set_index	net/reactor.cpp	/^    void set_index(int idx){index_=idx;}$/;"	f	class:Channel
set_revents	net/reactor.cpp	/^    void set_revents(int revt){\/\/设定fd的就绪事件类型，再poll返回就绪事件后将就绪事件类型传给此函数，然后此函数传给handleEvent，handleEvent根据就绪事件的类型决定执行哪个事件回调函数$/;"	f	class:Channel
setnonblock	test/pipe.cpp	/^int setnonblock( int fd )$/;"	f
setnonblocking	net/epoll_server.c	/^int setnonblocking(int sockfd)$/;"	f
setnonblocking	test/tick.c	/^int setnonblocking( int fd )\/\/将描述符fd设置为非阻塞$/;"	f
sh_sem	producer_consumer2.cpp	/^sem_t p_sem, c_sem, sh_sem;$/;"	v
show	thread/thread_race.cpp	/^        void show(){$/;"	f	class:test
show_list	test/any.cpp	/^void show_list(list_any &la)$/;"	f
sig_handler	test/tick.c	/^void sig_handler( int sig )\/\/信号处理函数这里将信号通过管道写端发送到主程序(统一事件源)$/;"	f
sig_pipe	test/pipe.cpp	/^static void sig_pipe(int signo)$/;"	f	file:
sig_usr	test/pipe.cpp	/^static void sig_usr(int signo)$/;"	f	file:
size	producer_consumer.cpp	/^int size = 0;$/;"	v
size	test/producer_consumer.c	/^int size = 0;$/;"	v
start	test/cthreadpoolmanage.cpp	/^int CthreadPoolManage::start()$/;"	f	class:CthreadPoolManage
startThread	test/cthreadpoolmanage.cpp	/^void* CthreadPoolManage::startThread(void* arg)$/;"	f	class:CthreadPoolManage
sub	typedef.c	/^int sub(int a, int b)$/;"	f
sub_from_lib	producer_consumer2.cpp	/^int sub_from_lib()                          \/\/从仓库中取出产品$/;"	f
subthread_count	thread/thread.c	/^int subthread_count = 0;$/;"	v
subthread_func	thread/thread.c	/^void *subthread_func(void *arg)$/;"	f
subthread_wait_flag	thread/thread.c	/^bool subthread_wait_flag = false;$/;"	v
swap	test/my_perms.cpp	/^void swap(char &a, char &b)$/;"	f
swap	thread/lock.cpp	/^void swap(test& a,test& b){\/\/$/;"	f
t_loopInThisThread	net/reactor.cpp	/^__thread EventLoop* t_loopInThisThread=0;\/\/线程私有数据表示线程是否拥有EventLoop$/;"	v
taskAllocation	test/cthreadpoolmanage.cpp	/^void* CthreadPoolManage::taskAllocation(void*arg)$/;"	f	class:CthreadPoolManage
test	boost/scope_ptr.cpp	/^void test()$/;"	f
test	thread/lock.cpp	/^        test(){$/;"	f	class:test
test	thread/lock.cpp	/^class test{\/\/持有一个互斥锁$/;"	c	file:
test	thread/thread_race.cpp	/^        test(){$/;"	f	class:test
test	thread/thread_race.cpp	/^class test{$/;"	c	file:
test_func	sync_add.c	/^void *test_func(void *arg)$/;"	f
thr	11/share_ptr.cpp	/^void thr(std::shared_ptr<Base> p)$/;"	f
thr_fn	thread/time_wait.c	/^void * thr_fn(void * arg)$/;"	f
thrd_start_routine	thread.cpp	/^void* thrd_start_routine(void* v)$/;"	f
thread	thread/time_wait.c	/^pthread_t thread;$/;"	v
thread1	test/c.c	/^void *thread1(void *junk)$/;"	f
thread1	thread/once.c	/^void *thread1(void *argv)$/;"	f
thread2	test/c.c	/^void *thread2(void *junk)$/;"	f
thread2	thread/once.c	/^void *thread2(void *argv)$/;"	f
threadCleanUp	test/cthreadpoolmanage.cpp	/^void CthreadPoolManage::threadCleanUp(void* arg)$/;"	f	class:CthreadPoolManage
threadFun	net/reactor.cpp	/^void* threadFun(void* arg){$/;"	f
threadID_	net/reactor.cpp	/^    const pid_t threadID_;\/\/EventLoop的附属线程ID$/;"	m	class:EventLoop	file:
thread_cond	thread/3_thread.c	/^pthread_cond_t thread_cond[THREAD_NUMBER];$/;"	v
thread_func	thread/3_thread.c	/^void *thread_func(void *arg)$/;"	f
thread_mutex	thread/3_thread.c	/^pthread_mutex_t thread_mutex[THREAD_NUMBER];$/;"	v
thread_turn	thread/3_thread.c	/^int thread_turn;$/;"	v
thread_wait_flag	thread/3_thread.c	/^bool thread_wait_flag[THREAD_NUMBER];$/;"	v
threading_test	test/switch.c	/^double threading_test()$/;"	f
timer_handler	test/tick.c	/^void timer_handler()\/\/超时处理逻辑$/;"	f
timer_lst	test/tick.c	/^static sort_timer_lst timer_lst;\/\/定时器容器链表类$/;"	v	file:
traverse	avl_tree.h	/^template<typename Type> void AVLTree<Type>::traverse(Node* p)const$/;"	f	class:AVLTree
traverseByLevel	avl_tree.h	/^template<typename Type> void AVLTree<Type>::traverseByLevel(Node* root)const$/;"	f	class:AVLTree
unlock	thread/lock.cpp	/^        void unlock(){$/;"	f	class:test
update	net/reactor.cpp	/^void Channel::update(){\/\/添加或修改文件描述符的事件类型$/;"	f	class:Channel
updateChannel	net/reactor.cpp	/^void EventLoop::updateChannel(Channel* channel){\/\/主要用于文件描述符添加到poll的监听事件集合中$/;"	f	class:EventLoop
updateChannel	net/reactor.cpp	/^void Poller::updateChannel(Channel* channel){$/;"	f	class:Poller
value_	boost/boost_fun.cpp	/^    int value_;$/;"	m	class:notifier	file:
vec_	boost/boost_fun.cpp	/^    std::vector<function_type> vec_;$/;"	m	class:notifier	file:
vec_length	test/v.c	/^long int vec_length(vec_ptr v)$/;"	f
vec_ptr	test/v.c	/^} vec_rec, *vec_ptr;$/;"	t	typeref:struct:__anon2	file:
vec_rec	test/v.c	/^} vec_rec, *vec_ptr;$/;"	t	typeref:struct:__anon2	file:
version	boost/boost_python/pyinit.hpp	/^    const char * version() {$/;"	f	class:pyinit
worker	net/close-shutdown.c	/^void* worker(void *data)$/;"	f
worker1	thread/lock.cpp	/^void* worker1(void* arg){\/\/线程1先锁a再锁b$/;"	f
worker1	thread/thread_race.cpp	/^void* worker1(void* arg){$/;"	f
worker2	thread/lock.cpp	/^void* worker2(void* arg){\/\/线程2先锁b再锁a，因此两个线程死锁$/;"	f
worker2	thread/thread_race.cpp	/^void* worker2(void* arg){$/;"	f
writeCallback	net/reactor.cpp	/^    EventCallback writeCallback;\/\/可写事件回调函数$/;"	m	class:Channel	file:
x	boost/enable_shared_from_this.cpp	/^    int x;$/;"	m	class:self_shared	file:
~AVLTree	avl_tree.h	/^template<typename Type> AVLTree<Type>::~AVLTree()$/;"	f	class:AVLTree
~Abstraction	design_pattern/bridge/Bridge.cpp	/^Abstraction::~Abstraction()$/;"	f	class:Abstraction
~Aggregate	design_pattern/iterator/Iterator.h	/^    virtual ~Aggregate(){}$/;"	f	class:Aggregate
~Base	11/share_ptr.cpp	/^    ~Base() { std::cout << "  Base::~Base()\\n"; }$/;"	f	struct:Base
~Builder	design_pattern/build/Builder.h	/^    virtual ~Builder(){}$/;"	f	class:Builder
~Component	design_pattern/composite/Composite.h	/^    virtual ~Component(){}$/;"	f	class:Component
~Component	design_pattern/decorator/Decorator.h	/^    virtual ~Component(){}$/;"	f	class:Component
~Composite	design_pattern/composite/Composite.cpp	/^Composite::~Composite()$/;"	f	class:Composite
~ConcreateAggregate	design_pattern/iterator/Iterator.cpp	/^ConcreateAggregate::~ConcreateAggregate()$/;"	f	class:ConcreateAggregate
~ConcreateBuilder1	design_pattern/build/Builder.h	/^    virtual ~ConcreateBuilder1(){}$/;"	f	class:ConcreateBuilder1
~ConcreateBuilder2	design_pattern/build/Builder.h	/^    virtual ~ConcreateBuilder2(){}$/;"	f	class:ConcreateBuilder2
~ConcreateComponent	design_pattern/decorator/Decorator.h	/^    virtual ~ConcreateComponent(){}$/;"	f	class:ConcreateComponent
~ConcreateDecorator	design_pattern/decorator/Decorator.h	/^    virtual ~ConcreateDecorator(){}$/;"	f	class:ConcreateDecorator
~ConcreateImplementorA	design_pattern/bridge/Bridge.h	/^    virtual ~ConcreateImplementorA(){}$/;"	f	class:ConcreateImplementorA
~ConcreateImplementorB	design_pattern/bridge/Bridge.h	/^    virtual ~ConcreateImplementorB(){}$/;"	f	class:ConcreateImplementorB
~ConcreateIterater	design_pattern/iterator/Iterator.h	/^    virtual ~ConcreateIterater(){}$/;"	f	class:ConcreateIterater
~ConcreateObserver	design_pattern/observer/Observer.h	/^    virtual ~ConcreateObserver(){}$/;"	f	class:ConcreateObserver
~ConcreateSubject	design_pattern/observer/Observer.h	/^    virtual ~ConcreateSubject(){}$/;"	f	class:ConcreateSubject
~CthreadPoolManage	test/cthreadpoolmanage.cpp	/^CthreadPoolManage::~CthreadPoolManage()$/;"	f	class:CthreadPoolManage
~Decorator	design_pattern/decorator/Decorator.cpp	/^Decorator::~Decorator()$/;"	f	class:Decorator
~Derived	11/share_ptr.cpp	/^    ~Derived() { std::cout << "  Derived::~Derived()\\n"; }$/;"	f	struct:Derived
~Director	design_pattern/build/Builder.cpp	/^Director::~Director()$/;"	f	class:Director
~EventLoop	net/reactor.cpp	/^EventLoop::~EventLoop(){$/;"	f	class:EventLoop
~Foo	11/unique_ptr.cpp	/^    ~Foo() { std::cout << "~Foo...\\n"; }$/;"	f	struct:Foo
~Garbo	design_pattern/singleton/Singleton.h	/^        ~Garbo()$/;"	f	class:Singleton::Garbo
~Implementor	design_pattern/bridge/Bridge.h	/^    virtual ~Implementor(){}$/;"	f	class:Implementor
~Iterater	design_pattern/iterator/Iterator.h	/^    virtual ~Iterater(){}$/;"	f	class:Iterater
~Leaf	design_pattern/composite/Composite.h	/^    virtual ~Leaf(){}$/;"	f	class:Leaf
~Observer	design_pattern/observer/Observer.h	/^    virtual ~Observer(){}$/;"	f	class:Observer
~Poller	net/reactor.cpp	/^Poller::~Poller(){}$/;"	f	class:Poller
~Proxy	design_pattern/proxy/Proxy.cpp	/^Proxy::~Proxy()$/;"	f	class:Proxy
~RealSubject	design_pattern/proxy/Proxy.h	/^    virtual ~RealSubject(){}$/;"	f	class:RealSubject
~ScopeMutex	test/a.cpp	/^    ~ScopeMutex(){$/;"	f	class:ScopeMutex
~Singleton	design_pattern/singleton/Singleton.h	/^    ~Singleton(){};    $/;"	f	class:Singleton
~Subject	design_pattern/observer/Observer.cpp	/^Subject::~Subject()$/;"	f	class:Subject
~Subject	design_pattern/proxy/Proxy.h	/^    virtual ~Subject(){}$/;"	f	class:Subject
~pyinit	boost/boost_python/pyinit.hpp	/^    ~pyinit() {}$/;"	f	class:pyinit
~test	thread/thread_race.cpp	/^        ~test(){$/;"	f	class:test
